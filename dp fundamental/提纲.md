# Dynamic Programming (DP) [动态规划] 刷题笔记

## 01. Fibonacci Alike [斐波那契类型]
$f(n) = f(n - 1) + f(n - 2)$

## 02 Matrix [矩阵]
最短路径： $f(i, j) = f(i - 1, j) + f(i, j - 1)$ 

最大正方形：$f(i, j) = \min(f(i - 1, j), f(i - 1, j - 1), dp(i, j - 1)) + 1$

## 03 Substr [字符子串]
回文串：$P(i, j) = P(i + 1, j - 1) \land (S_i == S_j)$

拆分法：$f[i] = f[j] \land check(s[j:i-1])$ [$check$项表示子串$s[j:i-1]$是否出现在字典中]

编辑距离：$D[i][j] = \left\{\begin{aligned}
  1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1] - 1) + 1; \text{if} A[i] = B[j] \\
  1 +  \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1]); \text{else} 
\end{aligned}\right.$

最小删除和： $f[i][j] = \left\{\begin{aligned}
  f[i - 1][j - 1]; s_1[i - 1] = s_2[j - 1]\\
  \min(f[i - 1][j] + s_1[i - 1], f[i][j - 1] + s_2[j - 1]); \text{else} 
\end{aligned}\right.$

不同子序列：$f[i][j] = \left\{\begin{aligned}
  f[i + 1][j + 1] + f[i + 1][j]; s[i] = t[j]\\
  f[i + 1][j] \text{else} 
\end{aligned}\right.$

## 04 Longest Increasing Subsequence (LIS) [最长递增子序列]

$f[i] = \max(dp[j]) + 1; 0 \leq j < i \land num[j] < num[i]$

最长等差数
$$
f[i][d][nums[i]] = \max(f[i - 1][d][num], f[i - 1][d][nums[i] - d] + 1)
$$

## 05 Longest Common Subseqence (LCS) [最长公共子序列]

$$
f[i][j] = \left\{ \begin{aligned}
  & f[i - 1][j - 1] + 1; & s[i - 1] = t[j - 1] \\ 
  & \max(f[i - 1][j], f[i][j - 1]); & \text{else}  
\end{aligned}\right.
$$

## 06 Finite State Machine (FSM) [状态机]: 以股票买卖为例

