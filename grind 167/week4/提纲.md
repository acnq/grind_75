有效率要求的题目就难了

1. 第4题开始难，关键是想到异或操作的特性：偶数次自抵消；
2. 回文链表和回文数：思路都是翻转后半部分，这样链表的tc能到$O(N)$, 数字的tc到$O(logN)$; 然后sc都是$O(1)$, 注意翻转了链表之后最好能翻转回来，tc不变
3. 对称树：两树对称 => A左树和B右树对称 && A右树和B左树对称, 注意中序遍历不能解决问题，比如中序结果[2,2,1,2,2], 左右子树的排列可以使得结果不对称。另外，此题也可以得到一个递归转循环的一般方法：模拟使用队列和指针
4. 平衡二叉树：关于中序遍历的重建：仅有中序遍历是无法重建一棵树的，即便要求树平衡也不行，但是，如果我们选择这个序列的中点作为根，并且对于左右部分都递归重复此操作，那么结果一定不会是不平衡的。证明在[这里](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)